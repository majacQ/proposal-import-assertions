<!doctype html>
<meta charset="utf8">
<script src="ecmarkup.js"></script>
<link rel="stylesheet" href="ecmarkup.css">
<title>Import Attributes</title>
<pre class="metadata">
  title: Import Attributes
  status: proposal
  stage: 3
  location: https://github.com/tc39/proposal-import-attributes
  copyright: false
  contributors: Sven Sauleau, Myles Borins, Daniel Ehrenberg, Daniel Clark, Nicol√≤ Ribaudo
</pre>

<emu-intro id="intro">
  <h1>Import Attributes</h1>
  <p>See <a href="https://github.com/tc39/proposal-import-attributes/blob/master/README.md">the explainer</a> for information.</p>
  <p>The relevant syntax changes are in the <a href="#sec-left-hand-side-expressions">Import Calls</a> and <a href="#sec-imports">Imports</a> sections.</p>

  <emu-note type="editor" style="background:#ffeedd">
    <p><strong>This document might be out of date</strong>. Please refer to <a href="https://ci.tc39.es/preview/tc39/ecma262/pull/3057">the tc39/ecma262#3057 preview</a> for the latest version.</p>
  </emu-note>
</emu-intro>

<emu-clause id="sec-ecmascript-language-expressions" number="13">
  <h1>ECMAScript Language: Expressions</h1>

  <emu-clause id="sec-left-hand-side-expressions" number="3">
    <h1>Left-Hand-Side Expressions</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      ImportCall[Yield, Await] :
        `import` `(` AssignmentExpression[+In, ?Yield, ?Await] <ins>`,`?</ins> `)`
        <ins>`import` `(` AssignmentExpression[+In, ?Yield, ?Await] `,` AssignmentExpression[+In, ?Yield, ?Await] `,`? `)`</ins>
    </emu-grammar>

    <emu-clause id="sec-import-calls" number="10">
      <h1>Import Calls</h1>

      <emu-clause id="sec-import-call-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>

        <emu-grammar><ins>ImportCall : `import` `(` AssignmentExpression `,`? `)`</ins></emu-grammar>
        <emu-alg>
          1. <ins>Return ? EvaluateImportCall(|AssignmentExpression|).</ins>
        </emu-alg>

        <emu-grammar><ins>ImportCall : `import` `(` AssignmentExpression `,` AssignmentExpression `,`? `)`</ins></emu-grammar>
        <emu-alg>
          1. <ins>Return ? EvaluateImportCall(the first |AssignmentExpression|, the second |AssignmentExpression|).</ins>
        </emu-alg>

        <emu-grammar><del>ImportCall : `import` `(` AssignmentExpression `)`</del></emu-grammar>
        <emu-alg>
          1. <del>Let _referrer_ be GetActiveScriptOrModule().</del>
          1. <del>If _referrer_ is *null*, set _referrer_ to the current Realm Record.</del>
          1. <del>Let _argRef_ be ? Evaluation of |AssignmentExpression|.</del>
          1. <del>Let _specifier_ be ? GetValue(_argRef_).</del>
          1. <del>Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).</del>
          1. <del>Let _specifierString_ be Completion(ToString(_specifier_)).</del>
          1. <del>IfAbruptRejectPromise(_specifierString_, _promiseCapability_).</del>
          1. <del>Perform HostLoadImportedModule(_referrer_, _specifierString_, ~empty~, _promiseCapability_).</del>
          1. <del>Return _promiseCapability_.[[Promise]].</del>
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-evaluate-import-call" type="abstract operation">
        <h1>
          <ins>
            EvaluateImportCall (
              _specifierExpression_: a ParseNode,
              optional _optionsExpression_: a ParseNode
            ): either a normal completion containing a Promise or a throw completion
          </ins>
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. Let _referrer_ be GetActiveScriptOrModule().
          1. If _referrer_ is *null*, set _referrer_ to the current Realm Record.
          1. Let _specifierRef_ be the result of evaluating _specifierExpression_.
          1. Let _specifier_ be ? GetValue(_specifierRef_).
          1. If _optionsExpression_ is present, then
            1. Let _optionsRef_ be the result of evaluating _optionsExpression_.
            1. Let _options_ be ? GetValue(_optionsRef_).
          1. Else,
            1. Let _options_ be *undefined*.
          1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
          1. Let _specifierString_ be Completion(ToString(_specifier_)).
          1. IfAbruptRejectPromise(_specifierString_, _promiseCapability_).
          1. Let _attributes_ be a new empty List.
          1. If _options_ is not *undefined*, then
            1. If Type(_options_) is not Object, then
              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; a newly created *TypeError* object &raquo;).
              1. Return _promiseCapability_.[[Promise]].
            1. Let _attributesObj_ be Completion(Get(_options_, *"with"*)).
            1. IfAbruptRejectPromise(_attributesObj_, _promiseCapability_).
            1. If _attributesObj_ is not *undefined*, then
              1. If Type(_attributesObj_) is not Object, then
                1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; a newly created *TypeError* object &raquo;).
                1. Return _promiseCapability_.[[Promise]].
              1. Let _entries_ be Completion(EnumerableOwnProperties(_attributesObj_, ~key+value~)).
              1. IfAbruptRejectPromise(_entries_, _promiseCapability_).
              1. For each _entry_ of _entries_, do
                1. Let _key_ be ! Get(_entry_, *"0"*).
                1. Let _value_ be ! Get(_entry_, *"1"*).
                1. If Type(_value_) is not String, then
                  1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; a newly created *TypeError* object &raquo;).
                  1. Return _promiseCapability_.[[Promise]].
                1. Append the ImportAttribute Record { [[Key]]: _key_, [[Value]]: _value_ } to _attributes_.
            1. If AllImportAttributesSupported(_attributes_) is *false*, then
              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; a newly created *TypeError* object &raquo;).
              1. Return _promiseCapability_.[[Promise]].
            1. Sort _attributes_ according to the lexicographic order of their [[Key]] fields, treating the value of each such field as a sequence of UTF-16 code unit values. NOTE: This sorting is observable only in that hosts are prohibited from distinguishing among attributes by the order they occur in.
          1. Let _moduleRequest_ be a new ModuleRequest Record { [[Specifier]]: _specifierString_, [[Attributes]]: _attributes_ }.
          1. Perform HostLoadImportedModule(_referrer_, _moduleRequest_, ~empty~, _promiseCapability_).
          1. Return _promiseCapability_.[[Promise]].
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-scripts-and-modules" number="16">
  <h1>ECMAScript Language: Scripts and Modules</h1>

  <emu-clause id="sec-modules" number="2">
    <h1>Modules</h1>

    <emu-clause id="sec-module-semantics">
      <h1>Module Semantics</h1>

      <emu-clause id="sec-modulerequest-record">
        <h1><ins>ModuleRequest and ImportAttribute Records</ins></h1>

        <p>A <dfn id="modulerequest-record" variants="ModuleRequest Records">ModuleRequest Record</dfn> represents the request to import a module with given import attributes. It consists of the following fields:</p>
        <emu-table id="table-modulerequest-fields" caption="ModuleRequest Record fields">
          <table>
            <tbody>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value Type
                </th>
                <th>
                  Meaning
                </th>
              </tr>
              <tr>
                <td>
                  [[Specifier]]
                </td>
                <td>
                  String
                </td>
                <td>
                  The module specifier
                </td>
              </tr>
              <tr>
                <td>
                  [[Attributes]]
                </td>
                <td>
                  a List of ImportAttribute Records
                </td>
                <td>
                  The import attributes
                </td>
              </tr>
            </tbody>
          </table>
        </emu-table>

        <emu-note type="editor">In general, this proposal replaces places where module specifiers are passed around with ModuleRequest Records. For example, several syntax-directed operations, such as ModuleRequests produce Lists of ModuleRequest Records rather than Lists of Strings which are interpreted as module specifiers. Some algorithms like ImportEntries and ImportEntriesForModule pass around ModuleRequest Records rather than Strings, in a way which doesn't require any particular textual change. Additionally, record fields in Cyclic Module Records and Source Text Module Records which contained Lists of Strings are replaced by Lists of ModuleRequest Records, as indicated above.</emu-note>

        <p><ins>A <dfn id="loadedmodulerequest-record" variants="LoadedModuleRequest Records">LoadedModuleRequest Record</dfn> represents the request to import a module together with the resulting Module Record. It consists of the same fields defined in table <emu-xref href="#table-modulerequest-fields"></emu-xref>, with the addition of [[Module]]:</ins></p>
        <emu-table id="table-loadedmodulerequest-fields" caption="LoadedModuleRequest Record fields">
          <table>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                [[Specifier]]
              </td>
              <td>
                a String
              </td>
              <td>
                The module specifier
              </td>
            </tr>
            <tr>
              <td>
                [[Attributes]]
              </td>
              <td>
                a List of ImportAttribute Records
              </td>
              <td>
                The import attributes
              </td>
            </tr>
            <tr>
              <td>
                [[Module]]
              </td>
              <td>
                a Module Record
              </td>
              <td>
                The loaded module corresponding to this module request
              </td>
            </tr>
          </table>
        </emu-table>

        <p><ins>An <dfn id="importattribute-record" variants="ImportAttribute Records">ImportAttribute Record</dfn> consists of the following fields:</ins></p>
        <emu-table id="table-importattribute-fields" caption="ImportAttribute Record fields">
          <table>
            <tbody>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value Type
                </th>
                <th>
                  Meaning
                </th>
              </tr>
              <tr>
                <td>
                  [[Key]]
                </td>
                <td>
                  String
                </td>
                <td>
                  The attribute key
                </td>
              </tr>
              <tr>
                <td>
                  [[Value]]
                </td>
                <td>
                  String
                </td>
                <td>
                  The attribute value
                </td>
              </tr>
            </tbody>
          </table>
        </emu-table>

        <emu-clause id="sec-ModuleRequestsEqual" type="abstract operation">
          <h1>
            <ins>
              ModuleRequestsEqual (
                _left_: a ModuleRequest Record or a LoadedModuleRequest Record,
                _right_: a ModuleRequest Record or a LoadedModuleRequest Record,
              ): a Boolean
            </ins>
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd></dd>
          </dl>

          <emu-alg>
            1. If _left_.[[Specifier]] is not _right_.[[Specifier]], return *false*.
            1. Let _leftAttrs_ be _left_.[[Attributes]].
            1. Let _rightAttrs_ be _right_.[[Attributes]].
            1. Let _leftAttrsCount_ be the number of elements in _leftAttrs_.
            1. Let _rightAttrsCount_ be the number of elements in _rightAttrs_.
            1. If _leftAttrsCount_ ‚â† _rightAttrsCount_, return *false*.
            1. For each ImportAttribute Record _l_ of _leftAttrs_, do
              1. Let _found_ be *false*.
              1. For each ImportAttribute Record _r_ of _rightAttrs_, do
                1. If _l_.[[Key]] is _r_.[[Key]], then
                  1. If _l_.[[Value]] is _r_.[[Value]], then
                    1. Assert: _found_ is *false*.
                    1. Set _found_ to *true*.
                  1. Else,
                    1. Return *false*.
              1. If _found_ is *false*, return *false*.
            1. Return *true*.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-static-semantics-modulerequests" type="sdo" number="3">
        <h1>
          Static Semantics: ModuleRequests ( ): a List of <del>Strings</del><ins>ModuleRequest Records</ins>
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>Module : [empty]</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItem</emu-grammar>
        <emu-alg>
          1. Return ModuleRequests of |ModuleItem|.
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. Let <del>_moduleNames_</del><ins>_requests_</ins> be ModuleRequests of |ModuleItemList|.
          1. Let <del>_additionalNames_</del><ins>_additionalRequests_</ins> be ModuleRequests of |ModuleItem|.
          1. <del>For each String _name_ of _additionalNames_, do</del>
          1. <ins>For each ModuleRequest Record _mr_ of _additionalRequests_, do</ins>
            1. If <del>_moduleNames_</del><ins>_requests_</ins> does not contain <del>_name_</del> <ins>a ModuleRequest Record _mr2_ such that ModuleRequestsEqual(_mr_, _mr2_) is *true*</ins>, then
              1. Append <del>_name_</del><ins>_mr_</ins> to <del>_moduleNames_</del><ins>_requests_</ins>.
          1. Return <del>_moduleNames_</del><ins>_requests_</ins>.
        </emu-alg>
        <emu-grammar>ModuleItem : StatementListItem</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>
          ImportDeclaration : `import` ImportClause FromClause `;`
        </emu-grammar>
        <emu-alg>
          1. <del>Return ModuleRequests of |FromClause|.</del>
          1. <ins>Let _specifier_ be SV of |FromClause|.</ins>
          1. <ins>Return a List whose sole element is the ModuleRequest Record { [[Specifer]]: _specifier_, [[Attributes]]: ¬´ ¬ª }.</ins>
        </emu-alg>
        <emu-grammar>
          <ins>ImportDeclaration : `import` ImportClause FromClause WithClause `;`</ins>
        </emu-grammar>
        <emu-alg>
          1. <ins>Let _specifier_ be the SV of |FromClause|.</ins>
          1. <ins>Let _attributes_ be WithClauseToAttributes of |WithClause|.</ins>
          1. <ins>Return a List whose sole element is the ModuleRequest Record { [[Specifer]]: _specifier_, [[Attributes]]: _attributes_ }.</ins>
        </emu-alg>
        <emu-grammar><ins>ImportDeclaration : `import` ModuleSpecifier `;`</ins></emu-grammar>
        <emu-alg>
          1. <ins>Let _specifier_ be the SV of |ModuleSpecifier|.</ins>
          1. <ins>Return a List whose sole element is the ModuleRequest Record { [[Specifer]]: _specifier_, [[Attributes]]: ¬´ ¬ª }.</ins>
        </emu-alg>
        <emu-grammar><ins>ImportDeclaration : `import` ModuleSpecifier WithClause `;`</ins></emu-grammar>
        <emu-alg>
          1. <ins>Let _specifier_ be the SV of |ModuleSpecifier|.</ins>
          1. <ins>Let _attributes_ be WithClauseToAttributes of |WithClause|.</ins>
          1. <ins>Return a List whose sole element is the ModuleRequest Record { [[Specifer]]: _specifier_, [[Attributes]]: _attributes_ }.</ins>
        </emu-alg>
        <emu-grammar><del>ModuleSpecifier : StringLiteral</del></emu-grammar>
        <emu-alg>
          1. <del>Return a List whose sole element is the SV of |StringLiteral|.</del>
        </emu-alg>
        <emu-grammar>
          ExportDeclaration : `export` ExportFromClause FromClause `;`
        </emu-grammar>
        <emu-alg>
          1. <del>Return ModuleRequests of |FromClause|.</del>
          1. <ins>Let _specifier_ be SV of |FromClause|.</ins>
          1. <ins>Return a List whose sole element is the ModuleRequest Record { [[Specifer]]: _specifier_, [[Attributes]]: ¬´ ¬ª }.</ins>
        </emu-alg>
        <emu-grammar>
          <ins>ExportDeclaration : `export` ExportFromClause FromClause WithClause `;`</ins>
        </emu-grammar>
        <emu-alg>
          1. <ins>Let _specifier_ be SV of |FromClause|.</ins>
          1. <ins>Let _attributes_ be WithClauseToAttributes of |WithClause|.</ins>
          1. <ins>Return a List whose sole element is the ModuleRequest Record { [[Specifer]]: _specifier_, [[Attributes]]: _attributes_ }.</ins>
        </emu-alg>
        <emu-grammar>
          ExportDeclaration :
            `export` NamedExports `;`
            `export` VariableStatement
            `export` Declaration
            `export` `default` HoistableDeclaration
            `export` `default` ClassDeclaration
            `export` `default` AssignmentExpression `;`
        </emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-cyclic-module-records" number="5">
        <h1>Cyclic Module Records</h1>
        <p>A <dfn id="cyclic-module-record" variants="Cyclic Module Records">Cyclic Module Record</dfn> is used to represent information about a module that can participate in dependency cycles with other modules that are subclasses of the Cyclic Module Record type. Module Records that are not subclasses of the Cyclic Module Record type must not participate in dependency cycles with Source Text Module Records.</p>
        <p>In addition to the fields defined in <emu-xref href="#table-module-record-fields"></emu-xref> Cyclic Module Records have the additional fields listed in <emu-xref href="#table-cyclic-module-fields"></emu-xref></p>
        <emu-table id="table-cyclic-module-fields" caption="Additional Fields of Cyclic Module Records">
          <table>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                [[Status]]
              </td>
              <td></td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[EvaluationError]]
              </td>
              <td></td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[DFSIndex]]
              </td>
              <td></td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[DFSAncestorIndex]]
              </td>
              <td></td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[RequestedModules]]
              </td>
              <td>
                a List of <del>Strings</del><ins>ModuleRequest Records</ins>
              </td>
              <td>
                A List of all the |ModuleSpecifier| strings <ins>and import attributes</ins> used by the module represented by this record to request the importation of a module. The List is in source text occurrence order.
              </td>
            </tr>
            <tr>
              <td>
                [[LoadedModules]]
              </td>
              <td>
                a List of <del>Records with fields [[Specifier]] (a String) and [[Module]] (a Module Record)</del><ins>LoadedModuleRequest Records</ins>
              </td>
              <td>
                A map from the specifier strings used by the module represented by this record to request the importation of a module <ins>with the relative attributes</ins> to the resolved Module Record. The list does not contain two different Records with the same <del>[[Specifier]]</del><ins>([[Specifier]], [[Attributes]]) pair</ins>.
              </td>
            </tr>
            <tr>
              <td>
                [[CycleRoot]]
              </td>
              <td></td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[HasTLA]]
              </td>
              <td></td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[AsyncEvaluation]]
              </td>
              <td></td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[TopLevelCapability]]
              </td>
              <td></td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[AsyncParentModules]]
              </td>
              <td></td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[PendingAsyncDependencies]]
              </td>
              <td></td>
              <td></td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-LoadRequestedModules" type="concrete method">
          <h1>
            LoadRequestedModules (
              optional _hostDefined_: anything,
            ): a Promise
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Cyclic Module Record _module_</dd>

            <dt>description</dt>
            <dd></dd>
          </dl>

          <emu-clause id="sec-InnerModuleLoading" type="abstract operation">
            <h1>
              InnerModuleLoading (
                _state_: a GraphLoadingState Record,
                _module_: a Module Record,
              ): ~unused~
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd>It is used by LoadRequestedModules to recursively perform the actual loading process for _module_'s dependency graph.</dd>
            </dl>

            <emu-alg>
              1. Assert: _state_.[[IsLoading]] is *true*.
              1. If _module_ is a Cyclic Module Record, _module_.[[Status]] is ~new~, and _state_.[[Visited]] does not contain _module_, then
                1. Append _module_ to _state_.[[Visited]].
                1. Let _requestedModulesCount_ be the number of elements in _module_.[[RequestedModules]].
                1. Set _state_.[[PendingModulesCount]] to _state_.[[PendingModulesCount]] + _requestedModulesCount_.
                1. For each <del>String</del><ins>ModuleRequest Record</ins> _request_ of _module_.[[RequestedModules]], do
                  1. <ins>If AllImportAttributesSupported(_request_.[[Attributes]]) is *false*, then</ins>
                    1. <ins>Let _error_ be ThrowCompletion(a newly created *SyntaxError* object).</ins>
                    1. <ins>Perform ContinueModuleLoading(_state_, _error_).</ins>
                  1. <ins>Else</ins> if _module_.[[LoadedModules]] contains a <del>Record _record_ such that _record_.[[Specifier]] is _request_</del> <ins>LoadedModuleRequest Record _record_ such that ModuleRequestsEqual(_record_, _request_) is *true*</ins>, then
                    1. Perform InnerModuleLoading(_state_, _record_.[[Module]]).
                  1. Else,
                    1. Perform HostLoadImportedModule(_module_, _request_, _state_.[[HostDefined]], _state_).
                    1. NOTE: HostLoadImportedModule will call FinishLoadingImportedModule, which re-enters the graph loading process through ContinueModuleLoading.
                  1. If _state_.[[IsLoading]] is *false*, return ~unused~.
              1. Assert: _state_.[[PendingModulesCount]] ‚â• 1.
              1. Set _state_.[[PendingModulesCount]] to _state_.[[PendingModulesCount]] - 1.
              1. If _state_.[[PendingModulesCount]] = 0, then
                1. Set _state_.[[IsLoading]] to *false*.
                1. For each Cyclic Module Record _loaded_ of _state_.[[Visited]], do
                  1. If _loaded_.[[Status]] is ~new~, set _loaded_.[[Status]] to ~unlinked~.
                1. Perform ! Call(_state_.[[PromiseCapability]].[[Resolve]], *undefined*, ¬´ *undefined* ¬ª).
              1. Return ~unused~.
            </emu-alg>
          </emu-clause>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-source-text-module-records" number="6">
        <h1>Source Text Module Records</h1>

        <p>An <dfn id="importentry-record" variants="ImportEntry Records">ImportEntry Record</dfn> is a Record that digests information about a single declarative import. Each ImportEntry Record has the fields defined in <emu-xref href="#table-importentry-record-fields"></emu-xref>:</p>
        <emu-table id="table-importentry-record-fields" caption="ImportEntry Record Fields" oldids="table-39">
          <table>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                [[ModuleRequest]]
              </td>
              <td>
                <del>String</del>
                <ins>ModuleRequest Record</ins>
              </td>
              <td>
                <del>String value of the |ModuleSpecifier| of the |ImportDeclaration|.</del>
                <ins>ModuleRequest Record representing the |ModuleSpecifier| and import attributes of the |ImportDeclaration|.</ins>
              </td>
            </tr>
            <tr>
              <td>
                [[ImportName]]
              </td>
              <td></td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[LocalName]]
              </td>
              <td></td>
              <td></td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-HostLoadImportedModule" type="host-defined abstract operation" number="8">
        <h1>
          HostLoadImportedModule (
            _referrer_: a Script Record, a Cyclic Module Record, or a Realm Record,
            <del>_specifier_: a String,</del>
            <ins>_moduleRequest_: a ModuleRequest Record,</ins>
            _hostDefined_: anything,
            _payload_: a GraphLoadingState Record or a PromiseCapability Record,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>

        <emu-note id="note-HostLoadImportedModule-referrer-Realm-Record">
          <p>An example of when _referrer_ can be a Realm Record is in a web browser host. There, if a user clicks on a control given by</p>

          <pre><code class="html">&lt;button type="button" onclick="import('./foo.mjs')"&gt;Click me&lt;/button&gt;</code></pre>

          <p>there will be no active script or module at the time the <emu-xref href="#sec-import-calls">`import()`</emu-xref> expression runs. More generally, this can happen in any situation where the host pushes execution contexts with *null* ScriptOrModule components onto the execution context stack.</p>
        </emu-note>

        <p>An implementation of HostLoadImportedModule must conform to the following requirements:</p>
        <ul>
          <li>
            The host environment must perform FinishLoadingImportedModule(_referrer_, <del>_specifier_</del><ins>_moduleRequest_</ins>, _payload_, _result_), where _result_ is either a normal completion containing the loaded Module Record or a throw completion, either synchronously or asynchronously.
          </li>
          <li>
            <p>If this operation is called multiple times with <del>the same</del><ins>two</ins> (_referrer_, <del>_specifier_</del><ins>_moduleRequest_</ins>) pair<ins>s</ins> such that:</p>
            <ul>
              <li><ins>the first _referrer_ is the same as the second _referrer_;</ins></li>
              <li><ins>ModuleRequestsEqual(the first _moduleRequest_, the second _moduleRequest_) is *true*;</ins></li>
              <li>it performs FinishLoadingImportedModule(_referrer_, <del>_specifier_</del><ins>_moduleRequest_</ins>, _payload_, _result_) where _result_ is a normal completion,</li>
            </ul>
            <p>then it must perform FinishLoadingImportedModule(_referrer_, <del>_specifier_</del><ins>_moduleRequest_</ins>, _payload_, _result_) with the same _result_ each time.</p>
          </li>
          <li>
            The operation must treat _payload_ as an opaque value to be passed through to FinishLoadingImportedModule.
          </li>
        </ul>

        <p>The actual process performed is host-defined, but typically consists of performing whatever I/O operations are necessary to load the appropriate Module Record. Multiple different <del>(_referrer_, _specifier_) pairs</del><ins>(_referrer_, _moduleRequest_.[[Specifer]], _moduleRequest_.[[Attributes]]) triples</ins> may map to the same Module Record instance. The actual mapping semantics is host-defined but typically a normalization process is applied to _specifier_ as part of the mapping process. A typical normalization process would include actions such as expansion of relative and abbreviated path specifiers.</p>
      </emu-clause>

      <emu-clause id="sec-FinishLoadingImportedModule" type="abstract operation" >
        <h1>
          FinishLoadingImportedModule (
            _referrer_: a Script Record, a Cyclic Module Record, or a Realm Record,
            <del>_specifier_: a String,</del>
            <ins>_moduleRequest_: a ModuleRequest Record,</ins>
            _payload_: a GraphLoadingState Record or a PromiseCapability Record,
            _result_: either a normal completion containing a Module Record or a throw completion,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>
        <emu-alg>
          1. If _result_ is a normal completion, then
            1. If _referrer_.[[LoadedModules]] contains a <del>Record</del><ins>LoadedModuleRequest</ins> _record_ such that <del>_record_.[[Specifier]] is _specifier_</del><ins>ModuleRequestsEqual(_record_, _moduleRequest_) is *true*</ins>, then
              1. Assert: _record_.[[Module]] is _result_.[[Value]].
            1. Else, append the Record { [[Specifier]]: <del>_specifier_</del><ins>_moduleRequest_.[[Specifer]]</ins>, <ins>[[Attributes]]: _moduleRequest_.[[Attributes]]</ins>, [[Module]]: _result_.[[Value]] } to _referrer_.[[LoadedModules]].
          1. If _payload_ is a GraphLoadingState Record, then
            1. Perform ContinueModuleLoading(_payload_, _result_).
          1. Else,
            1. Perform ContinueDynamicImport(_payload_, _result_).
          1. Return ~unused~.
        </emu-alg>

        <emu-note type="editor">
          <p>The description of the [[LoadedModules]] field of Realm Record, Script Record, and Cyclic Module Record should be updated to use LoadedModuleRequest Records.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-AllImportAttributesSupported" type="abstract operation">
        <h1>
          <ins>
            AllImportAttributesSupported (
              _attributes_: a List of ImportAttribute Records,
            ): a Boolean
          </ins>
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>
        <emu-alg>
          1. Let _supported_ be HostGetSupportedImportAttributes().
          1. For each ImportAttribute Record _attribute_ of _attributes_, do
            1. If _supported_ does not contain _attribute_.[[Key]], return *false*.
          1. Return *true*.
        </emu-alg>

        <emu-clause id="sec-hostgetsupportedimportattributes" type="host-defined abstract operation">
          <h1>
            <ins>
              HostGetSupportedImportAttributes ( ): a List of Strings
            </ins>
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It allows host environments to specify which import attributes they support. Only attributes with supported keys will be provided to the host.</dd>
          </dl>

          <p>An implementation of HostGetSupportedImportAttributes must conform to the following requrements:</p>

          <ul>
            <li>It must return a List of Strings, each indicating a supported attribute.</li>

            <li>Each time this operation is called, it must return the same List with the same contents in the same order.</li>

            <li>An implementation of HostGetSupportedImportAttributes must always complete normally (i.e., not return an abrupt completion).</li>
          </ul>

          <p>The default implementation of HostGetSupportedImportAttributes is to return a new empty List.</p>

          <emu-note><ins>The purpose of requiring the host to specify its supported import attributes, rather than passing all attributes to the host and letting it then choose which ones it wants to handle, is to ensure that unsupported attributes are handled in a consistent way across different hosts.</ins></emu-note>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-imports">
      <h1>Imports</h1>

      <emu-grammar type="definition">
        ImportDeclaration :
          `import` ImportClause FromClause <ins>WithClause?</ins> `;`
          `import` ModuleSpecifier <ins>WithClause?</ins> `;`

        <ins>
          WithClause :
            AttributesKeyword `{` `}`
            AttributesKeyword `{` WithEntries `,`? `}`

          AttributesKeyword :
            `with`

          WithEntries :
            AttributeKey `:` StringLiteral
            AttributeKey `:` StringLiteral `,` WithEntries

          AttributeKey :
            IdentifierName
            StringLiteral
        </ins>
      </emu-grammar>

      <emu-clause id="sec-imports-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>

        <emu-grammar>
          <ins>
            WithClause : AttributesKeyword `{` WithEntries `,`? `}`
          </ins>
        </emu-grammar>
        <ul>
          <li><ins>It is a Syntax Error if WithClauseToAttributes of |WithClause| has two entries _a_ and _b_ such that _a_.[[Key]] is _b_.[[Key]].</ins></li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-with-clause-to-attributes" type="sdo">
        <h1>
          <ins>
            Static Semantics: WithClauseToAttributes (
            ): a List of ImportAttribute Records
          </ins>
        </h1>
        <dl class="header">
        </dl>

        <emu-grammar>
          WithClause : AttributesKeyword `{` `}`
        </emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>

        <emu-grammar>
          WithClause : AttributesKeyword `{` WithEntries `,`? `}`
        </emu-grammar>
        <emu-alg>
          1. Let _attributes_ be WithClauseToAttributes of |WithEntries|.
          1. Sort _attributes_ according to the lexicographic order of their [[Key]] fields, treating the value of each such field as a sequence of UTF-16 code unit values. NOTE: This sorting is observable only in that hosts are prohibited from distinguishing among attributes by the order they occur in.
          1. Return _attributes_.
        </emu-alg>

        <emu-grammar>WithEntries : AttributeKey `:` StringLiteral</emu-grammar>
        <emu-alg>
          1. Let _key_ be the PropName of |AttributeKey|.
          1. Let _entry_ be the ImportAttribute Record { [[Key]]: _key_, [[Value]]: SV of |StringLiteral| }.
          1. Return ¬´ _entry_ ¬ª.
        </emu-alg>

        <emu-grammar>WithEntries : AttributeKey `:` StringLiteral `,` WithEntries</emu-grammar>
        <emu-alg>
          1. Let _key_ be the PropName of |AttributeKey|.
          1. Let _entry_ be the ImportAttribute Record { [[Key]]: _key_, [[Value]]: SV of |StringLiteral| }.
          1. Let _rest_ be WithClauseToAttributes of |WithEntries|.
          1. Return the list-concatenation of ¬´ _entry_ ¬ª and _rest_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-exports">
      <h1>Exports</h1>

      <emu-grammar>
        ExportDeclaration :
          `export` ExportFromClause FromClause <ins>WithClause?</ins> `;`
          `export` NamedExports `;`
          `export` VariableStatement[~Yield, ~Await]
          `export` Declaration[~Yield, ~Await]
          `export` `default` HoistableDeclaration[~Yield, ~Await, +Default]
          `export` `default` ClassDeclaration[~Yield, ~Await, +Default]
          `export` `default` [lookahead &lt;! {`function`, `async` [no |LineTerminator| here] `function`, `class`}] AssignmentExpression[+In, ~Yield, ~Await] `;`
      </emu-grammar>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-annex id="sec-host-integration">
  <h1>Sample host integration: The Web embedding</h1>

  <p>The import attributes proposal is intended to give key information about how modules are interpreted to hosts. For the Web embedding and environments which aim to be similar to it, the string is interpreted as the "module type". This is not the primary way the module type is determined (which, on the Web, would be the MIME type, and in other environments may be the file extension), but rather a secondary check which is required to pass for the module graph to load.</p>

  <p>In the Web embedding, the following changes would be made to the HTML specification for import attributes:</p>

  <ul>
    <li>The <a href="https://html.spec.whatwg.org/#module-script">module script</a> would have an additional item, which would be the module type, as a string (e.g., *"json"*), or *undefined* for a JavaScript module.</li>
    <li>HostLoadImportedModule would take a ModuleRequest Record parameter in place of a specifier string, which would be passed down through several abstract operations to reach the <a href="https://html.spec.whatwg.org/#fetch-a-single-module-script">fetch a single module script</a> algorithm. Somewhere near the entrypoint, if the ModuleRequest Record's [[Attributes]] field has an element _entry_ such that _entry_.[[Key]] is *"type"*, then let _type_ be _entry_.[[Value]]; otherwise let _type_ be *undefined*. If the type is invalid, then an exception is thrown and module loading fails. Otherwise, this will equal the module type, if the module can be successfully fetched with a matching MIME type.</li>
    <li>In the <a href="https://html.spec.whatwg.org/#fetch-the-descendants-of-a-module-script">fetch the descendents of a module script</a> algorithm, when iterating over [[RequestedModules]], the elements are ModuleRequest Records rather than just specifier strings; these Records is passed on to the internal module script graph fetching procedure (which sends it to "fetch a single module script". Other usage sites of [[RequestedModules]] ignore the attribute.</li>
    <li>"Fetch a single module script" would check the attribute in two places:
      <ul>
        <li>The module map is keyed with both the absolute URL and the module type, so an existing entry will be found only if its _type_ matches.</li>
        <li>When a new module is fetched, before writing it into the module map, the MIME type is checked to ensure that it matches _type_. (Note that the interpretation of the module is still driven by the MIME type, but once the MIME type is established, this is checked against the _type_.) If they differ, then an exception is thrown and module loading fails. The _type_ is written into the module script as the type.</li>
      </ul>
    </li>
  </ul>

  <p>The module map is keyed by the absolute URL and the _type_. Initially no other import attributes are supported, so they are not present.</p>
</emu-annex>
